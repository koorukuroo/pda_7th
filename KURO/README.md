### 1. 세대별/크기별 성능 비교: T2 vs T3 (구형 vs 신형)

T2(Xen)와 T3(Nitro) 인스턴스의 크기 및 시나리오별 전체 테스트 결과입니다.

| 세대 (Family) | 크기 (Size) | 시나리오 | RPS (처리량) | 평균 응답시간 | P99 응답시간 (최악) | 실패율 (Fail%) | 비고 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| **T2** | micro | 기본 (Basic) | 27.91 | 12,014 ms | 56,000 ms | 55.8% |  |
| **T2** | micro | **극한 (Stress)** | 28.22 | 12,898 ms | 57,000 ms | 66.8% | 성능 저하 심각 |
| **T2** | medium | 기본 (Basic) | 29.68 | 10,617 ms | 34,000 ms | 50.6% |  |
| **T2** | medium | **극한 (Stress)** | 28.61 | 13,329 ms | 54,000 ms | 52.5% | Steal Time 발생 |
| **T2** | 2xlarge | 기본 (Basic) | 29.01 | 11,390 ms | 38,000 ms | 51.2% |  |
| **T2** | 2xlarge | **극한 (Stress)** | 29.08 | 12,878 ms | 54,000 ms | 51.5% |  |
| **T3** | medium | 기본 (Basic) | **33.42** | 10,711 ms | 42,000 ms | 56.4% | **동급 T2 대비 +12% 성능** |
| **T3** | medium | **극한 (Stress)** | **32.61** | **11,500 ms** | 56,000 ms | 52.9% | **Latency 방어 우수** |
| **T3** | 2xlarge | 기본 (Basic) | 32.94 | 11,117 ms | 41,000 ms | 52.3% |  |
| **T3** | 2xlarge | **극한 (Stress)** | 31.07 | 11,809 ms | 44,000 ms | 56.9% |  |

> **📌 분석 결과**
> * 모든 구간에서 **T3가 T2보다 약 10~15% 높은 RPS**를 기록함.
> * 특히 **극한(Stress) 상황**에서 T2는 응답 시간이 급격히 느려지나(13.3초), T3는 상대적으로 안정적임(11.5초).
> 
> 

---

### 2. 스펙별 성능 비교: C6i 시리즈 (Scale-up 효율성)

최신 인스턴스인 C6i의 vCPU 개수 증가에 따른 성능 변화 테스트 결과입니다.

| 모델명 | vCPU | 시나리오 | RPS (처리량) | 평균 응답시간 | P99 응답시간 | 실패율 (Fail%) | 가성비 평가 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| **C6i.large** | 2 | 기본 (Basic) | **49.60** | **6,648 ms** | 18,000 ms | 58.3% | ⭐ **Best** |
| **C6i.large** | 2 | **극한 (Stress)** | **48.34** | **6,679 ms** | 18,000 ms | 59.6% | **안정적 방어** |
| **C6i.xlarge** | 4 | 기본 (Basic) | 39.90 | 11,292 ms | 27,000 ms | 51.1% | 성능 하락 |
| **C6i.xlarge** | 4 | **극한 (Stress)** | 37.96 | 14,709 ms | 33,000 ms | 59.6% | 불안정 |
| **C6i.2xlarge** | 8 | 기본 (Basic) | 48.50 | 6,570 ms | 18,000 ms | 58.5% | Large와 동일 |
| **C6i.2xlarge** | 8 | **극한 (Stress)** | 47.35 | 8,116 ms | 21,000 ms | 58.7% | 비용 낭비 |

> **📌 분석 결과**
> * **병목 현상(Bottleneck):** vCPU를 2개(Large)에서 8개(2xlarge)로 4배 늘렸으나, **RPS는 49 → 48로 변화가 없음.**
> * **원인:** Python Single Thread 한계로 인해 추가 코어를 전혀 활용하지 못함.
> * **결론:** 고사양 인스턴스(Scale-up)는 효과가 없으며, **C6i.large(2 vCPU)가 최적의 선택**임.
> 
> 

---

### 3. 모니터링 및 안정성 검증 (CPU Endurance Test)

Netdata를 활용하여 부하 테스트(15분 지속) 중 CPU의 실시간 상태를 분석했습니다. 이를 통해 T3 인스턴스의 'CPU 크레딧' 정책이 실제 서비스에 미치는 영향을 시각적으로 검증했습니다.

#### ① C6i.large : 안정적인 성능 유지 (Stable)
<img width="2304" height="796" alt="image" src="https://github.com/user-attachments/assets/5f291217-64ad-42fd-942b-8ea9086b8784" />

* **관측 결과:** 지속적인 고부하 상황(Load)에서도 CPU 사용률이 100%로 일정하게 유지됨.
* **분석:** `Steal Time`이나 성능 저하 없이 요청을 안정적으로 처리함. 전용 하드웨어(Dedicated Hardware) 기반 인스턴스의 이점이 확인됨.

#### ② T3.medium : 크레딧 고갈 및 성능 저하 (Throttling)

<img width="2394" height="726" alt="image" src="https://github.com/user-attachments/assets/4849669b-1416-409c-bcf6-3afa6f97ce1a" />

* **관측 결과:** 테스트 시작 약 15분 경과 후, 그래프 높이가 급격히 하락하며 불안정한 파동을 그림.
* **분석 (핵심):**
1. **Credit Exhaustion:** CPU 크레딧이 모두 소진되어 강제 성능 제한(Throttling) 발생.
2. **Steal Time 발생:** 그래프 상단의 **붉은 영역(Steal)**은 물리적 CPU 자원을 할당받지 못해 발생하는 대기 시간(Lag)을 의미함.


* **결론:** 선착순 이벤트와 같이 트래픽이 지속되는 환경에서는 T계열 인스턴스가 서비스 지연(Latency Spike)의 원인이 될 수 있음.
