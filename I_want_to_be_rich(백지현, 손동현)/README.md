# 📊 AWS EC2 인스턴스 성능 비교: 금융 데이터 분석 벤치마크

## 1. 실험 목적

이 프로젝트는 **금융 데이터 분석 워크로드**를 기준으로 다양한 AWS EC2 인스턴스의 성능을 정량적으로 비교하여, 용도별 최적 인스턴스를 선정하는 것을 목표로 하였다.

특히 KOSPI와 NASDAQ 지수 간의 **상관관계 분석 및 회귀 분석**과 같은 통계 연산을 반복 수행하여, 순수 CPU 연산 성능을 측정하였다.

## 무엇을 했을까! 토글을 보자! 📊 💰 💵 🇰🇷 🇺🇸
<details>
<summary> 📈📈📈 KOSPI🇰🇷 vs NASDAQ🇺🇸 상관·베타 분석 (Stooq CSV)</summary>


## 1. 목적
**한국 주식시장(KOSPI)이 미국 주식시장(NASDAQ)의 움직임과 얼마나 같이 움직이는지**,  
그리고 **미국 시장의 변동에 한국 시장이 얼마나 민감하게 반응하는지**를 정량적으로 분석

특히,
- 같은 날의 관계(same-day)와
- **전일 NASDAQ → 당일 KOSPI(lag1)** 관계 중  
어느 쪽이 더 설명력이 있는지를 확인하는 것이 목적이다.
    - Lag1은 전일 NASDAQ 수익률이 다음 날 KOSPI 수익률에 얼마나 영향을 미치는지를 보기 위한 시간차 변수
    - Lag1은 달력 날짜가 아니라 시장 세션 기준으로, 전일 미국 시장(한국 시간 새벽 마감)이 당일 한국 시장(아침 개장)에 반영되는 관계를 의미한다.



## 2. 어떤 데이터를 사용했는가
- 데이터 출처: **Stooq**
- 데이터 형식: 일별 CSV (HTTP 다운로드)
- 사용 지수:
  - KOSPI 지수 (`^kospi`)
  - NASDAQ Composite 지수 (`^ndq`)
- 사용 컬럼: **Date, Close(종가)**
- 분석 기간: **2016-01-01 ~ 최신**


## 3. 어떤 연산을 했는가

### (1) 수익률 계산
- 종가를 **로그수익률**로 변환
\[
r_t = \ln(P_t) - \ln(P_{t-1})
\]
    * 로그 수익률은 기간별로 더해서 누적 수익률을 표현할 수 있어 시계열 분석에 적합      
    * 분포가 더 안정적이고 대칭적이라 상관관계·회귀(베타) 같은 통계 분석에 유리

### (2) 상관관계 분석
- Same-day: `KOSPI(t)` vs `NASDAQ(t)`
- Lag1: `KOSPI(t)` vs `NASDAQ(t-1)`

→ 두 시장이 얼마나 함께 움직이는지 측정

### (3) 베타(회귀) 분석
OLS 회귀로 NASDAQ 변동에 대한 KOSPI의 민감도를 계산

- Same-day 회귀  
\[
KOSPI_t = \alpha + \beta \cdot NASDAQ_t
\]

- Lag1 회귀  
\[
KOSPI_t = \alpha + \beta \cdot NASDAQ_{t-1}
\]

→ β(베타), R², p-value를 통해 영향력과 통계적 유의성 판단


## 4. 어떤 결과를 얻었는가
출력되는 핵심 결과는 다음 두 세트다.

- **Same-day 결과**
  - 상관계수(Corr)
  - 베타(beta)
  - 설명력(R²)
  - 유의확률(p-value)

- **Lag1 결과**
  - 상관계수(Corr)
  - 베타(beta)
  - 설명력(R²)
  - 유의확률(p-value)

<img width="400" height="400" alt="스크린샷 2026-01-09 오전 9 14 28" src="https://github.com/user-attachments/assets/96212335-37f5-46e7-863b-91314ee37982" />
<img width="400" height="400" alt="image" src="https://github.com/user-attachments/assets/905f7a37-457a-4689-8086-2a5b02729def" />

<img width="400" height="400" alt="image" src="https://github.com/user-attachments/assets/5e5a8d8b-a219-454e-95d4-9f6fe896e9c3" /><img width="400" height="400" alt="image" src="https://github.com/user-attachments/assets/225e3afa-07a6-4e36-843d-cd5973d2464e" />





## 5. 결론

분석 결과, 같은 날(Same-day)보다 **전일 NASDAQ → 당일 KOSPI(Lag1)** 관계가 더 뚜렷하게 나타났다.

- Same-day 관계는 상관계수 0.192, 베타 0.154로 약한 수준이며  
  설명력(R²=0.037)도 낮아 NASDAQ 변동이 같은 날 KOSPI 변동을 충분히 설명하지 못한다.
- 반면 Lag1 관계는 상관계수 0.343, 베타 0.275로 더 크고,  
  설명력(R²=0.118)과 통계적 유의성(p < 0.001)도 확보되었다.



## 6. 한 줄 요약 💵💵💵

> > **KOSPI는 같은 날의 NASDAQ보다, 전일 NASDAQ 변동이 다음 날 시장에 반영되는 경향이 더 뚜렷하다 (NASDAQ(t−1) → KOSPI(t)).**




</details>



## 2. 실험 환경 및 설정

### 2.1 테스트 대상 인스턴스

<table>
  <tr>
    <td>

| 인스턴스  | vCPU | RAM | 아키텍처    | 특징          |
| --------- | ---- | --- | ----------- | ------------- |
| t3.micro  | 2    | 1GB | x86 (Intel) | 버스트형      |
| t3.small  | 2    | 2GB | x86 (Intel) | 버스트형      |
| t3.medium | 2    | 4GB | x86 (Intel) | 버스트형      |
| t3.large  | 2    | 8GB | x86 (Intel) | 버스트형      |
| m4.large  | 2    | 8GB | x86 (Intel) | 구세대 범용형 |
| m5.large  | 2    | 8GB | x86 (Intel) | 최신 범용형   |
| c7i.large | 2    | 4GB | x86 (Intel) | CPU 최적화    |

</td>
<td>

<img src="https://github.com/user-attachments/assets/60001ae6-79ac-4d53-924a-2041b7b34458" width="450"/>

</td>
  </tr>
</table>



### 2.2 실험 조건

- **데이터 소스**: Stooq CSV API (KOSPI: ^KS11, NASDAQ: ^IXIC)
- **분석 기간**: 2016-01-01 ~ 현재 (약 2,500일)
- **총 데이터**: 약 4,976 rows
- **벤치마크 설정**:
  - `USE_CACHE=True`: 네트워크 영향 제거 (로컬 CSV 재사용)
  - `BENCH_REPEAT=80`: CPU 부하 확대를 위한 80회 반복 실행
  - `WARMUP_REPEAT=3`: 캐시 워밍업 3회
  - `SHOW_PLOTS=False`: 그래프 출력 비활성화 (순수 연산만 측정)

### 2.3 측정 지표

- **실행 시간**: 다운로드+정렬 시간, 분석 반복 시간
- **처리량**: rows/sec (총 데이터 행 수 × 반복 횟수 ÷ 분석 시간)
- **CPU 사용률**: 평균 및 최대 사용률 (%)
- **메모리 사용량**: RSS 기준 평균 및 최대 (MB)

---


### 2.4 성능 측정 방식

**네트워크와 CPU 연산을 분리하여 측정**하였다:

1. **다운로드+정렬 시간**: 첫 실행 시 네트워크 다운로드 포함 (1회만)
2. **분석 반복 시간**: 캐시된 데이터로 순수 CPU 연산만 80회 반복
3. **처리량**: `(데이터 행 수 × 80) ÷ 분석 시간`으로 계산

이를 통해 **네트워크 지연의 영향을 제거**하고, 순수한 인스턴스 연산 성능만을 비교할 수 있었다.



## 3. 실험 결과

### 3.1 전체 성능 비교

| 인스턴스      | 분석시간(s) | 처리량(rows/s) | CPU평균(%) | 메모리(MB) |
| ------------- | ----------- | -------------- | ---------- | ---------- |
| **c7i.large** | **0.463**   | **410,443**    | 65.4       | 183        |
| **m5.large**  | 0.778       | 244,262        | 86.8       | 183        |
| m4.large      | 0.815       | 233,164        | 67.9       | 184        |
| t3.small      | 0.855       | 222,132        | 62.3       | 185        |
| t3.medium     | 0.908       | 209,259        | 67.8       | 184        |
| t3.micro      | 0.929       | 204,554        | 64.1       | 183        |
| t3.large      | 1.079       | 175,965        | 72.3       | 183        |

### 3.2 성능 순위

#### 처리 속도 (빠른 순)

1. **c7i.large** - 410,443 rows/s (기준)
2. m5.large - 244,262 rows/s (1.68배 느림)
3. m4.large - 233,164 rows/s (1.76배 느림)
4. t3.small - 222,132 rows/s (1.85배 느림)
5. t3.medium - 209,259 rows/s (1.96배 느림)
6. t3.micro - 204,554 rows/s (2.01배 느림)
7. t3.large - 175,965 rows/s (2.33배 느림) ⚠️



## 4. 분석 및 인사이트

### 4.1 CPU 최적화 인스턴스의 압도적 우위

**c7i.large**가 2위인 m5.large 대비 **1.68배 빠른 성능**을 보였다. 이는 금융 데이터 분석이 다음과 같은 특성을 가지기 때문이다:

- **CPU 집약적**: 수익률 계산, 상관계수, OLS 회귀는 순수 연산 작업
- **메모리 요구량 낮음**: 모든 인스턴스에서 184MB만 사용
- **I/O 최소화**: 캐시 사용으로 디스크/네트워크 영향 제거

따라서 **CPU 클럭 속도와 캐시 구조**가 성능을 좌우하며, C 계열 인스턴스가 이러한 작업에 최적화되어 있음을 확인하였다.

### 4.2 범용형 인스턴스 세대 차이

**m5.large vs m4.large 비교**:

| 항목       | m5.large (최신) | m4.large (구세대) | 차이        |
| ---------- | --------------- | ----------------- | ----------- |
| 처리량     | 244,262 rows/s  | 233,164 rows/s    | **+4.8%**   |
| CPU 사용률 | 86.8%           | 67.9%             | 높은 활용도 |

동일한 스펙(2 vCPU, 8GB RAM)임에도 **m5가 m4보다 빠른 성능**을 보였다. 이는 Intel Xeon 프로세서 세대 차이(Broadwell/Haswell → Skylake/Cascade Lake)에 기인한 것으로 추정된다.

**결론**: 구세대 인스턴스는 피하고, **최신 세대를 선택하는 것이 중요**하다.

### 4.3 버스트 인스턴스의 예상치 못한 결과

#### ⚠️ t3.large가 가장 느린 이유

**예상**: t3 계열에서 스펙이 높을수록 성능이 좋을 것
**실제**: t3.large가 **t3.micro보다 14% 느림**

```
t3.micro  (1GB)  →  204,554 rows/s
t3.small  (2GB)  →  222,132 rows/s  (+8.6%)
t3.medium (4GB)  →  209,259 rows/s  (-5.8%)
t3.large  (8GB)  →  175,965 rows/s  (-16.0%) ❌
```

#### 왜 이런 결과가 나왔을까?

**1. CPU 크레딧 소진 (버스트 특성)**

t3 인스턴스는 **버스트 성능 모델**을 사용한다:

- **베이스라인 CPU**: 지속 가능한 기본 성능 (20~40%)
- **CPU 크레딧**: 일시적으로 100% 성능을 낼 수 있는 토큰

우리 실험은:

- 80회 반복 실행 (총 약 1초)
- 짧은 시간이지만 **지속적인 고부하**

t3.large는 **크레딧 소진 후 베이스라인으로 제한**되었을 가능성이 높다. 반면 t3.micro/small은 짧은 작업이라 크레딧 내에서 처리되었을 것으로 추정된다.

**2. 메모리 과잉 (낭비)**

모든 인스턴스에서 **메모리 사용량 183~185MB로 동일**하였다:

- t3.micro (1GB): 18% 사용
- t3.large (8GB): **2.3% 사용** → 7GB 이상 낭비

이 워크로드는 메모리 집약적이지 않아, RAM 증가가 **전혀 도움되지 않았다**.

### 4.4 인스턴스 패밀리별 특성 정리

| 패밀리                   | 특징                  | 이 워크로드 적합도 | 추천 용도                |
| ------------------------ | --------------------- | ------------------ | ------------------------ |
| **C 계열**               | CPU 최적화, 고클럭    | ⭐⭐⭐ 최고        | 금융 분석, ML 학습       |
| **M 계열**               | 범용형, 균형잡힌 스펙 | ⭐⭐ 양호          | 웹/API 서버, DB          |
| **T 계열 (micro/small)** | 버스트형, 저가        | ⭐⭐ 양호          | 개발/테스트, 간헐적 작업 |
| **T 계열 (large 이상)**  | 버스트형, 과한 스펙   | ❌ 비효율          | 이 작업엔 부적합         |


## 5. 결론 및 권장 사항

### 5.1 시나리오별 최적 인스턴스

| 시나리오                    | 추천 인스턴스           | 이유                     |
| --------------------------- | ----------------------- | ------------------------ |
| **프로덕션: 성능 최우선**   | **c7i.large**           | 410k rows/s, CPU 최적화  |
| **프로덕션: 균형잡힌 선택** | **m5.large**            | 안정적 성능, 범용성      |
| **개발/테스트 환경**        | **t3.micro / t3.small** | 저사양으로도 충분한 성능 |
| **간헐적 배치 작업**        | **t3.small**            | 적당한 성능              |
| ❌ **비추천**               | t3.large, m4.large      | 낮은 효율, 구세대        |
