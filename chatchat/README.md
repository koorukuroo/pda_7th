# EC2 인스턴스 성능 비교 실험 보고서 - 💰 금융 어시스턴트 챗봇

개인 재무 관리 + RAG 기반 금융 Q&A 통합 플랫폼

## 1. 목적 
본 테스트는 금융 챗봇 본 실험은 금융 챗봇 + RAG + 크롤링 통합 서비스 환경에서 AWS EC2 인스턴스 유형(T4g.micro, C6g.medium)에 따른 성능 차이를 비교하여 **비용 대비 안정적이고 확장 가능한 인스턴스 선택 기준을 도출하는 것**을 목적으로 합니다.

## 🎯 주요 기능

### 1. 💬 재무 분석 챗봇
- 자연어로 수입/지출 입력 및 관리
- 실시간 지출 패턴 분석
- AI 기반 맞춤형 예산 추천
- 저축 목표 설정 및 진행 상황 추적

### 2. 📊 재무 대시보드
- 실시간 수입/지출 현황
- 카테고리별 지출 분석 (파이 차트)
- 일평균 지출 및 순 저축 통계
- 최근 거래 내역 조회

### 3. 📚 RAG 기반 금융 Q&A
- 100+ 금융 용어 데이터베이스
- 벡터 검색 기반 정확한 답변 제공
- 출처 포함 신뢰성 높은 정보
- 관련 용어 추천 및 비교 기능

### 4. 📰 최신 금융 뉴스
- 네이버/위키백과 등 다중 소스 크롤링
- LLM 기반 뉴스 자동 요약
- 클릭 가능한 원문 링크 제공
- 키워드 자동 감지

### 5. ➕ 거래 관리
- 수입/지출 간편 입력
- 10개 카테고리 분류 (식비, 교통비, 쇼핑 등)
- 날짜별 거래 내역 관리
- 설명 메모 기능

---

## 🔬 AWS 인스턴스 성능 벤치마크

### 실험 목적
서로 다른 AWS EC2 인스턴스 타입에서 동일한 금융 어시스턴트 챗봇 애플리케이션을 실행하여, **CPU 아키텍처**, **메모리 용량**, **컴퓨팅 최적화** 차이가 실제 성능에 미치는 영향을 정량적으로 측정 및 비교

---

## 📋 실험 설계

### 가설

**H1**: CPU 최적화 인스턴스(C6g)가 범용 인스턴스(T4g, R4)보다 높은 처리량(TPS)을 보일 것이다.

**H2**: 메모리 최적화 인스턴스(R4)는 메모리 집약적 작업(RAG 임베딩)에서 안정적인 성능을 보일 것이다.

**H3**: ARM 기반 Graviton 프로세서(T4g, C6g)가 x86 기반(R4)보다 비용 대비 성능이 우수할 것이다.

### 테스트 인스턴스

| 인스턴스 타입 | vCPU | 메모리 | 아키텍처 | 특징 | 시간당 비용 (서울) |
|--------------|------|--------|----------|------|-------------------|
| **T4g.micro** | 2 | 1GB | ARM (Graviton2) | 버스트 가능 범용 | $0.0084 |
| **C6g.medium** | 1 | 2GB | ARM (Graviton2) | CPU 최적화 | $0.034 |
| **R4.large** | 2 | 15.25GB | x86 (Intel) | 메모리 최적화 | $0.133 |

### 측정 지표

#### 1. 크롤링 성능
- 측정 항목: 100개 금융 용어 생성 시간
- 단위: 초

#### 2. 부하 테스트 (50명, 5분)
- 측정 항목: 메모리 사용률, CPU 사용률
- 패턴: 금융 Q&A, 재무 챗봇, 거래 추가

#### 3. 고부하 테스트 (1000명, 3분)
- 측정 항목: 총 요청 수, 실패 수, 평균 응답 시간, 최대 응답 시간
- 목적: 극한 상황에서의 안정성 측정

---

## 📊 실험 결과

### 1. 크롤링 성능 비교

| 인스턴스 | 크롤링 시간 | 성능 |
|---------|-----------|------|
| T4g.micro | 7.98초 | 기준 (100%) |
| C6g.medium | 8.01초 | 99.6% |
| R4.large | 7.82초 | **102.0%** ⭐ |

**결과**: 크롤링 작업에서는 인스턴스 간 성능 차이 미미 (±2%)

---

### 2. 일반 부하 테스트 (50명, 5분)

#### T4g.micro
```
[부하 테스트 조건]
- 사용자: 50명 동시 접속
- 부하 지속: 5분
- 요청 패턴: 금융 Q&A, 재무 챗봇, 거래 추가

[측정 결과]
메모리:
  - 초기: 72.3%
  - 최대: 77.1% (+4.8%)
  - 평균: 75.4%
  - 결론: 메모리 사용률 높음 ⚠️

CPU:
  - 초기: 4.5-12.5%
  - 부하 중: 85-90% (지속)
  - 평균: 약 85%
  - 결론: CPU 높은 사용률, 여유 있음 ✅
```

#### C6g.medium
```
[부하 테스트 조건]
- 사용자: 50명 동시 접속
- 부하 지속: 5분
- 요청 패턴: 금융 Q&A, 재무 챗봇, 거래 추가

[측정 결과]
메모리:
  - 초기: 58.2%
  - 최대: 59.3% (+1.1%)
  - 평균: 58.8%
  - 결론: 메모리 여유 있음 ✅

CPU:
  - 초기: 9-18%
  - 부하 중: 100% (지속)
  - 평균: 거의 100%
  - 결론: CPU 병목 현상 ⚠️
```

#### 소결

| 지표 | T4g.micro | C6g.medium | 우세 |
|------|-----------|------------|------|
| 메모리 사용률 | 75.4% (높음) | 58.8% (여유) | **C6g** ⭐ |
| CPU 사용률 | 85% (여유) | 100% (병목) | **T4g** ⭐ |
| 메모리 증가량 | +4.8% | +1.1% | **C6g** |
| CPU 코어 수 | 2 | 1 | **T4g** |

**분석**: 
- T4g.micro는 2개 vCPU로 CPU 여유가 있으나, 1GB 메모리로 인한 제약
- C6g.medium은 2GB 메모리로 여유 있으나, 1개 vCPU로 병목 발생
- **50명 부하에서는 T4g.micro가 더 안정적**

---

### 3. 고부하 테스트 (1000명, 3분)

| 지표 | T4g.micro | C6g.medium | R4.large | 최고 성능 |
|------|-----------|------------|----------|-----------|
| **총 요청 수** | 2,593 | 3,296 | 3,055 | **C6g** ⭐ |
| **실패 수** | 3 | 119 | 35 | **T4g** ⭐ |
| **실패율** | **0.12%** | 3.61% | 1.15% | **T4g** ⭐ |
| **평균 응답 시간** | **2,012ms** | 3,612ms | 2,610ms | **T4g** ⭐ |
| **최대 응답 시간** | **6,801ms** | 22,244ms | 35,008ms | **T4g** ⭐ |
| **처리량 (TPS)** | 14.4 req/s | **18.3 req/s** | 17.0 req/s | **C6g** ⭐ |

---

## 🎯 종합 분석

### 성능 비교 매트릭스

| 카테고리 | T4g.micro | C6g.medium | R4.large |
|---------|-----------|------------|----------|
| **크롤링 속도** | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| **일반 부하 안정성** | ⭐⭐⭐⭐ | ⭐⭐⭐ | N/A |
| **고부하 처리량** | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| **응답 시간** | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ |
| **안정성 (실패율)** | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ |
| **비용 효율성** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐ |

### 주요 발견

#### ✅ 가설 검증 결과

**H1** (CPU 최적화 인스턴스가 높은 처리량): **부분 채택** ✓
- C6g.medium이 최고 처리량 (18.3 TPS) 달성
- 그러나 높은 실패율(3.61%)과 응답 시간(3.6초)으로 인한 트레이드오프 존재

**H2** (메모리 최적화 인스턴스의 안정성): **기각** ✗
- R4.large가 오히려 최대 응답 시간 35초로 가장 불안정
- 메모리 최적화가 이 워크로드에는 과도한 스펙

**H3** (ARM Graviton의 비용 효율성): **채택** ✓✓
- T4g.micro: 최고의 비용 대비 성능 ($0.0084/시간, 실패율 0.12%)
- C6g.medium: 높은 처리량 대비 합리적인 비용 ($0.034/시간)

---

## 💡 핵심 인사이트

### 1. 메모리 vs CPU 트레이드오프

| 워크로드 특성 | 권장 인스턴스 | 이유 |
|--------------|--------------|------|
| **안정성 중시** (50명 이하) | **T4g.micro** | 2 vCPU가 부하 분산, 낮은 실패율 |
| **처리량 중시** (100명 이상) | **C6g.medium** | 높은 TPS, 메모리 여유 |
| **대용량 메모리** 필요 | **R4.large** | 15GB 메모리 (오버스펙) |

### 2. 비용 효율성 분석

| 인스턴스 | 1000 TPS 달성 비용 | 실패 1건당 비용 | 종합 평가 |
|---------|-------------------|----------------|----------|
| T4g.micro | **$0.58/hr** | $2.80 | ⭐⭐⭐⭐⭐ 최고 |
| C6g.medium | $1.86/hr | $0.29 | ⭐⭐⭐⭐ 우수 |
| R4.large | $7.82/hr | $3.80 | ⭐⭐ 비효율 |

**계산식**: `(시간당 비용) / (처리량/1000) / (1-실패율)`

### 3. 실전 권장사항

#### 시나리오 A: 스타트업 MVP (예산 $50/월)
```
권장: T4g.micro
- 비용: ~$6/월 (730시간)
- 처리 가능: 동시 50명, 월 1M+ 요청
- 장점: 극도의 비용 효율, 낮은 실패율
- 단점: 메모리 제약 (75% 사용률)
```

#### 시나리오 B: 성장 단계 (예산 $200/월)
```
권장: C6g.medium
- 비용: ~$25/월
- 처리 가능: 동시 100-150명
- 장점: 높은 처리량, 메모리 여유
- 단점: 1 vCPU로 인한 CPU 병목
```

#### 시나리오 C: 엔터프라이즈 (높은 안정성 요구)
```
권장: C6g.large (2 vCPU, 4GB)
- 비용: ~$50/월
- 처리 가능: 동시 300+ 명
- 장점: CPU/메모리 균형, 확장성
```

---

## 📈 성능 최적화 제안

### 병목 해소 방안

| 병목 지점 | 현상 | 해결책 |
|----------|------|--------|
| **C6g CPU 100%** | 1 vCPU 포화 | C6g.large 업그레이드 (2 vCPU) |
| **T4g 메모리 75%** | 1GB 제약 | 스왑 메모리 추가 또는 T4g.small (2GB) |
| **R4 높은 지연** | 과도한 메모리 | 워크로드에 맞게 다운사이징 |

### 코드 레벨 최적화
```python
# 1. RAG 검색 결과 캐싱
from functools import lru_cache

@lru_cache(maxsize=100)
def cached_rag_search(query):
    return rag_system.search(query)

# 2. 비동기 처리
async def handle_multiple_requests():
    tasks = [process_request(req) for req in requests]
    return await asyncio.gather(*tasks)

# 3. 배치 임베딩
embeddings = model.encode(texts, batch_size=32)  # 기본 8 → 32
```

---

## 🏆 최종 결론

### 종합 순위

| 순위 | 인스턴스 | 종합 점수 | 추천 용도 |
|------|---------|----------|-----------|
| 🥇 | **T4g.micro** | 92/100 | MVP, 소규模 서비스 (< 50명) |
| 🥈 | **C6g.medium** | 85/100 | 성장 단계, 중규模 (100-150명) |
| 🥉 | **R4.large** | 62/100 | 메모리 집약 워크로드 (비추천) |

### 평가 기준
- 처리량 (25점)
- 안정성/실패율 (25점)
- 응답 시간 (20점)
- 비용 효율성 (20점)
- 확장 가능성 (10점)

---

## 🔮 향후 실험 계획

1. **C6g.large** 테스트 → CPU 병목 해소 확인
2. **T4g.small** 테스트 → 메모리 제약 해소 확인
3. **Auto Scaling** 구성 → 탄력적 확장 성능 측정
4. **Multi-AZ** 배포 → 고가용성 검증
5. **CloudFront + API Gateway** → CDN 효과 측정

---

**최종 업데이트**: 2026-01-09  
**테스트 환경**: AWS Seoul Region (ap-northeast-2)  
**Python 버전**: 3.11  
**FastAPI 버전**: 0.104.1

